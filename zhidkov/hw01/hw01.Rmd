---
title: "Домашнее задание №1"
author: "Ilya Zhidkov"

output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Работа с данными.
По адресу http://www.stats.uwo.ca/faculty/braun/data/rnf6080.dat можно получить набор данных об осадках в Канаде с 1960 по 1980 годы. Необходимо загрузить эти данные при помощи ``read.table``. Воспользуйтесь справкой, чтобы изучить аргументы, которые принимает функция.   
Загрузите данные в датафрейм, который назовите ``data.df``.   

```{r}
data.df = read.table("http://www.stats.uwo.ca/faculty/braun/data/rnf6080.dat")
```

- Сколько строк и столбцов в ``data.df``? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы.    
5070x27   

```{r}
# число строк
print(nrow(data.df))

#число столбцов
print(ncol(data.df))
```

- Получите имена колонок из ``data.df``.
```{r}
data.df.colnames <- colnames(data.df)
```

- Найдите значение из 5 строки седьмого столбца.

```{r}
data.df[5,7]
```

- Напечатайте целиком 2 строку из ``data.df``

```{r}
data.df[2,]
```

- Объясните, что делает следующая строка кода ``names(data.df) <- c("year", "month", "day", seq(0,23))``. Воспользуйтесь функциями ``head`` и ``tail``, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?

```{r}
names(data.df) <- c("year", "month", "day", seq(0,23))
head(data.df)
tail(data.df)
```

**Ответ**   
Данная строка кода задает имена колонок у загруженной таблицы. В результате выполнения первые три столбца получают имена  `year`, `month`, `day` соответственной, следующие - номера с `0` по `23`    
Последние 24 колонки показывают количество осадков по часам.    

- Добавьте новую колонку с названием *daily*, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?

```{r}
data.df["daily"] <- rowSums(data.df[(length(data.df.colnames)-23):length(data.df.colnames)])
hist(data.df[["daily"]])
```

**Ответ**   
По гистограмме можно сделать вывод, что в столбце `daily` присутствуют отрицательные значения.

- Создайте новый датафрейм ``fixed.df`` в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.    
*Для того, чтобы исправить ошибку, необходимо взять модуль значений столбца `daily`.*

```{r}
fixed.df = data.df
fixed.df[["daily"]] = abs(fixed.df[["daily"]])
hist((fixed.df[["daily"]]))
```

## Синтаксис и типизирование    
* Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.
```{r}
v <- c("4", "8", "15", "16", "23", "42")
max(v)
sort(v)
```

```
sum(v)

```

**Ответ**     
Вектор v представляет собой массив строковых значений.
В случае нахождения максимального элемента, был получен элемент со значением 8, так как сравнение происходит по первому элементу стрингового значения и в случае их совпадениях переходит к следующему. Именно поэтому отсортированный массив начинается с 15, а после идет 16.    
В случае нахождения суммы элементов вектора всплывает ошибка ``Ошибка в sum(v) :неправильный 'type' (character) аргумента``, что говорит о неверном типе для вычисления суммы (нечисловой аргумент), т.е. нет возможности конкатенировать строковые знчения.    

* Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочны.

```{r}
v2 <- c("5",7,12)
# v2[2] + 2[3]
# тут наверное должно быть v2[2] + v2[3]?
```

**Ответ**   
Невозможно суммирование элементов вектора типа char, так как + работате только с числовыми аргументами.    

```{r}
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]
```

**Ответ**   
Data Frame поддерживает работу с разными типами данными, поэтому в данном случае выполнится сложение.   

```{r}
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
#l4[2] + l4[4]
```

**Ответ**   
В списках (листах)  оператор [] - выводит список элементов по индексу, а [[]] - сам элемент, поэтому в первом случае выполнится сложение, а во втором - отобразится ошибка.  

## Работа с функциями и операторами
* Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции ``seq()``, которую вы использовали раньше. Изучите эту функцию, вызвав команду ``?seq``. Испольуя полученные знания выведите на экран:
    1. Числа от 1 до 10000 с инкрементом 372. 
```{r}  
print(seq(1, 10000, by=372))
```
    2. Числа от 1 до 10000 длиной 50.
    
```{r}
print(seq(1, 10000, length.out = 50))
```

* Функция ``rep()`` повторяет переданный вектор указанное число раз. Объясните разницу между ``rep(1:5,times=3)`` и ``rep(1:5, each=3)``.    

```{r}
print(rep(1:5, times=3))
print(rep(1:5, each=3))
```

**Ответ**   
Параметр times определяет количество повторений самой последовательности, а параметр each - количество повторений каждого элемента.
